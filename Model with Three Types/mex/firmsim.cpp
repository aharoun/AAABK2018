#include <stdlib.h>#include <string.h>#include <math.h>#include <time.h>#include <mex.h>#include "MersenneTwister.h"using namespace std;///////////////////////////////////////////////////////////////////////////////// Constants///////////////////////////////////////////////////////////////////////////////#define nT 4 // number of threads#define nF 32768#define R_BURN 10000#define REAL_TIME 5.0#define T_PERIODS 5#define nN 128     // -h: max number of product line a firm can have#define nNpow 6#define N_FTYPES 3#define FTYPE_LO 0#define FTYPE_ME 1#define FTYPE_HI 2#define N_DTYPES 3#define DTYPE_GAIN 0#define DTYPE_FREE 1#define DTYPE_ENTR 2#define nS 8             // -h: number of transition states#define nSpow 3#define STATE_NOTHING 0#define STATE_LOSE    1#define STATE_FREE    2#define STATE_GAIN    3#define STATE_AGE     4#define STATE_EXIT    5///////////////////////////////////////////////////////////////////////////////// Structs///////////////////////////////////////////////////////////////////////////////typedef struct{  int*    age_out;  int*    type_out;  int*    nprod_out;  double* empl_out;  int*    exited_out;  int*    norig_out;  double* empl_orig_out;  int*    last_state_out;} info_out;///////////////////////////////////////////////////////////////////////////////// Device kernels///////////////////////////////////////////////////////////////////////////////// sequential search for small leninline int dsamp1(double* pbeg, int len, double r){  double* ppos = pbeg;  double* pend = pbeg + len;  int s = 0;  while (ppos < pend) {    if (r < (*ppos)) {      break;    }    s++;    ppos++;  }  return s;}// binary search (only powers of 2 sizes)inline int dsamp2(double* pbeg, int pow2, double r){  int len = 1<<(pow2-1); // -h: 2^(pow2-1)  int pos = len-1;         double val;  for (int s = 0; s < (pow2-1); s++) {    len /= 2;								// -h: half of it    val = pbeg[pos];    pos += (r < val) ? -len : len;  }  val = pbeg[pos];  pos += (r > val) ? 1 : 0;  return pos;}///////////////////////////////////////////////////////////////////////////////// MEX code///////////////////////////////////////////////////////////////////////////////void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]){  // read in arguments  if (nrhs != 17) {    printf("Too few input arguments.\n");    return;  }  if (nlhs != 10) {    printf("Too few output arguments.\n");    return;  }  // Handle matlab data  // firmsim(nBpow,qbins_v{tid},qdists_v{tid},xt,qmint,taut,rhot,xoutt,epst,g,nu,psi,pqual,int32(R_PER_T),seed_v{tid});   int nBpow         = mxGetScalar(prhs[0]);  double* m_qbins   = (double*)mxGetData(prhs[1]); // N_FTYPES*nB  double* m_qdists  = (double*)mxGetData(prhs[2]); // N_DTYPES*N_FTYPES*nB  double* xs        = (double*)mxGetData(prhs[3]); // N_FTYPES  double* qmins     = (double*)mxGetData(prhs[4]); // N_FTYPES  double tau        = mxGetScalar(prhs[5]);  double rho        = mxGetScalar(prhs[6]);  double xout       = mxGetScalar(prhs[7]);  double eps        = mxGetScalar(prhs[8]);  double g          = mxGetScalar(prhs[9]);  double nuML       = mxGetScalar(prhs[10]);  double nuHL       = mxGetScalar(prhs[11]);  double psi        = mxGetScalar(prhs[12]);  double alphaM     = mxGetScalar(prhs[13]);  double alphaH     = mxGetScalar(prhs[14]);  int R_PER_T       = mxGetScalar(prhs[15]);  unsigned int SEED = (unsigned int)mxGetScalar(prhs[16]);  int nB            = 1<<nBpow;    // -h: 2^nBpow  int R_SIM         = T_PERIODS*R_PER_T;  int R_TOT         = R_BURN+R_SIM;  int qbN           = mxGetN(prhs[1]);  int qbM           = mxGetM(prhs[1]);  int qbL           = max(qbN,qbM);  if (qbL != nB) {    printf("nBpow wrong.\n");    return;  }  // initialize RNG  MTRand* mt = new MTRand(SEED);  // input values  double delt = 1.0/R_PER_T;   			// discretization  double qdec = 1.0/(1.0+delt*g);  double pqualM = alphaM;  double pqualH = alphaH;  // dists  double* qdists[9] = {m_qdists,m_qdists+nB,m_qdists+2*nB,m_qdists+3*nB,m_qdists+4*nB,m_qdists+5*nB,m_qdists+6*nB,m_qdists+7*nB,m_qdists+8*nB};  double* qbins[3]  = {m_qbins,m_qbins+nB,m_qbins+2*nB};  // transition table  int nel_tt = N_FTYPES*(nN+1)*nS;  size_t ttsize = sizeof(double)*nel_tt;  double* tvecs = (double*)malloc(ttsize);    //Allocates a block of size bytes of memory, returning a pointer to the beginning of the block.  double* svec;  double ssum;  double nut;  double xt;      for (int t = 0; t < N_FTYPES; t++) {    if (t == 0){      nut = 0;      // low type    }else if (t == 1){      nut = nuML;    // medium type    }else{      nut = nuHL;    // high type    }    xt = xs[t];    for (int n = 0; n < nN+1; n++) {        svec = tvecs + t*(nN+1)*nS + n*nS;              ssum    = 1.0;      svec[7] = ssum;      svec[6] = ssum;      svec[5] = ssum;      ssum   -= psi*delt;      svec[4] = ssum;      ssum   -= nut*delt;          svec[3] = ssum;      ssum   -= (n*xt)*delt;      svec[2] = ssum;      ssum   -= (n*rho)*delt;      svec[1] = ssum;      ssum   -= (n*tau)*delt;      svec[0] = ssum;    }   }     if (ssum <= 0.0) printf("delt too large.");  // output arrays, -h: here they are created  mxArray* m_age 		     = mxCreateNumericMatrix(nF,T_PERIODS+1,mxINT32_CLASS,mxREAL);  mxArray* m_type 	     = mxCreateNumericMatrix(nF,T_PERIODS+1,mxINT32_CLASS,mxREAL);  mxArray* m_nprod 		   = mxCreateNumericMatrix(nF,T_PERIODS+1,mxINT32_CLASS,mxREAL);  mxArray* m_empl 		   = mxCreateDoubleMatrix(nF,T_PERIODS+1,mxREAL);  mxArray* m_exited 	   = mxCreateNumericMatrix(nF,T_PERIODS+1,mxINT32_CLASS,mxREAL);  mxArray* m_norig 		   = mxCreateNumericMatrix(nF,T_PERIODS+1,mxINT32_CLASS,mxREAL);  mxArray* m_empl_orig 	 = mxCreateDoubleMatrix(nF,T_PERIODS+1,mxREAL);  mxArray* m_last_state  = mxCreateNumericMatrix(nF,T_PERIODS+1,mxINT32_CLASS,mxREAL);  mxArray* m_ngain_rnd 	 = mxCreateNumericMatrix(nF,T_PERIODS+1,mxINT32_CLASS,mxREAL);  mxArray* m_ngain_res 	 = mxCreateNumericMatrix(nF,T_PERIODS+1,mxINT32_CLASS,mxREAL);  int* h_age 			    = (int*)mxGetData(m_age);  int* h_type 			  = (int*)mxGetData(m_type);  int* h_nprod 			  = (int*)mxGetData(m_nprod);  double* h_empl 		  = (double*)mxGetData(m_empl);  int* h_exited 		  = (int*)mxGetData(m_exited);  int* h_norig 			  = (int*)mxGetData(m_norig);  double* h_empl_orig	= (double*)mxGetData(m_empl_orig);  int* h_last_state 	= (int*)mxGetData(m_last_state);  int* h_ngain_rnd 		= (int*)mxGetData(m_ngain_rnd);  int* h_ngain_res 		= (int*)mxGetData(m_ngain_res);  //-h: assigned to the output  plhs[0] = m_age;  plhs[1] = m_type;  plhs[2] = m_nprod;  plhs[3] = m_empl;  plhs[4] = m_exited;  plhs[5] = m_norig;  plhs[6] = m_empl_orig;  plhs[7] = m_last_state;  plhs[8] = m_ngain_rnd;  plhs[9] = m_ngain_res;  //plhs[10] = m_qualEnd;  //////////////////////  // SIMULATION START //  //////////////////////  // local vars  int     s;  int     qind;  int     tech;  int     bin;  double  qval;  double  qvald;  double  qeps1;  double  r;  double  qmin;  double* tvec;  double  ran;  // tracking stats  int     prime_time = 0;      int     r_sub;  int     period;  int     norig;  int     ngain_rnd = 0;  int     ngain_res = 0;  double  emp;  double  emp_orig;  int     last_state = -1;  int     entry_ind;  // initial firm state  int     exited  = 0;  int     age     = 0;  int     type    = 0;  int     n       = 0;  double  quals[nN];   int     orig[nN];  double  qualDummy = 1;    int rep;  for (int f = 0; f < nF; f++) {   // loop over firms    //mexPrintf("%s%d\n", "Firm: ", f);    for (int rep = 0; rep <= R_BURN+R_SIM; rep++) {  // simulation steps      // handle exits and first rep      if (n == 0) {        // store cause of exit        if ((prime_time == 1) && (exited == 0)) last_state = s;         // init firm chars        exited 	  = 1;           age 	    = 0;            ran = mt -> rand();        if (ran < pqualH){          type = 2;        }else if(ran < (pqualH + pqualM)){          type = 1;        }else{          type = 0;        }                // first product        while (qualDummy==1) {        	qind = dsamp2(qdists[type*N_DTYPES+DTYPE_ENTR],nBpow,mt->rand()); //  quality is chosen from randomly from entry distribution        	qval = qbins[type][qind];        	if (qval>=qmins[type]) {        		  qualDummy = 0;        	}        }        quals[0] = qval;        qualDummy = 1;        n = 1;      }      // aggregate statistics      if (rep >= R_BURN) {           if (rep == R_BURN) {          prime_time  = 1;          period      = 0;          r_sub       = 0;          norig       = 0;          ngain_rnd   = 0;          ngain_res   = 0;          emp_orig    = 0.0;          exited      = 0;          for (qind = 0; qind < n; qind++) {            orig[qind] = 1;             }                           }        r_sub++;         if ((r_sub == R_PER_T) || (rep == R_BURN)) {             emp = 0.0;                                 emp_orig = 0.0;          norig = 0;          for (qind = 0; qind < n; qind++) {            qval = quals[qind];            qeps1 = pow(qval,eps-1.0);            emp += qeps1;              if (orig[qind] == 1) {              emp_orig += qeps1;                norig += 1;                                                       }          }          h_age[period*nF+f]        = age;          h_type[period*nF+f]       = type;          h_nprod[period*nF+f]      = n;          h_empl[period*nF+f]       = emp;          h_exited[period*nF+f]     = exited;          h_norig[period*nF+f]      = norig;          h_empl_orig[period*nF+f]  = emp_orig;          h_last_state[period*nF+f] = last_state;          h_ngain_rnd[period*nF+f]  = ngain_rnd;          h_ngain_res[period*nF+f]  = ngain_res;                                   r_sub = 0;           period++;        }      }      // the sampler      tvec = tvecs + type*(nN+1)*nS + n*nS;        s = dsamp1(tvec,nS,mt->rand());      r = mt->rand();      switch (s) {        case STATE_EXIT:          n = 0;          break;        case STATE_AGE:          type = 0;          //type = type - 1;          break;        case STATE_GAIN:          if (n < nN) {            qind = dsamp2(qdists[type*N_DTYPES+DTYPE_GAIN],nBpow,r);               qval = qbins[type][qind];            quals[n] = qval;               orig[n] = 0;                   n++;            ngain_rnd++;          }          break;        case STATE_FREE:           if (n < nN) {            qind = dsamp2(qdists[type*N_DTYPES+DTYPE_FREE],nBpow,r);            qval = qbins[type][qind];            quals[n] = qval;            orig[n] = 0;            n++;            ngain_res++;          }          break;        case STATE_LOSE:          if (n > 0) {            qind = floor(r*n);              qval = quals[qind];             quals[qind] = quals[n-1];            orig[qind] = orig[n-1];            n--;          }          break;      }      // decrement by growth      qmin = qmins[type];      for (qind = n-1; qind >= 0; qind--) {        qval = quals[qind];        qvald = qdec*qval;        if (qvald < qmin) {          quals[qind] = quals[n-1];          orig[qind] = orig[n-1];          n--;        } else {          quals[qind] = qvald;        }      }      // increment age      age++;     }  }  // Free device memory  free(tvecs);}